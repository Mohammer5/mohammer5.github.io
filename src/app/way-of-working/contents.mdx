# WIP: Way of working

**This page is still <u>work in progress</u>! Some sections and all chapters haven't
been completed yet. Having said that, I think this already paints a somewhat
clear picture of how I like to work**

On this page, I'll describe very briefly the ideal development
situation I'd like to work in. This will cover code-related topics
but also team work and organizing tasks. I have two main focuses:
Firstly I want to maximize business results, secondly I want to equally
maximize employee satisfaction. In my opinion, it's not just possible to
achieve both, the latter is actually very good for the former! Happy employees
work better. Happy employees are happy (this tautology is on purpose!)

* [Development](#development)
  * Do not reinvent the wheel
  * Simplicity is the key
  * Simple software
  * Software design
* [Management](#management)
  * Solution-oriented problem solving
  * Decisions should be reached through inclusion, The decision-making process must be explicit
  * Communication is the key
  * Meetings
  * Adressing bugs before features
  * Features and rejecting feature requests
* [Tl;dr & Link-list](#tldr)

<a name="development"></a>
## Development

The primary goal of writing software is to make it serve a purpose. In most
cases that's quite straight forward: Generate profit. In other cases, it's 
more about solving a particular problem (e.g. what non-profit organizations
do).

In any case, in order to achieve the goal, writing high-quality software is not
really necessary. But once the initial profits come in and the software needs
to be extended (e.g. to stay ahead of competitors) or adjusted (e.g. to changed
requirements), having high quality software is a significant competitive
advantage. This brings up the most important question: What does high-quality
software mean; and: How do you achieve it?

The answer to the first question is surprisingly straight forward: Software
needs to be simple, it's the key to maintainable, scalable, and usable
software. And it's quite easy to explain: It's easy to change simple
software, and likewise it's difficult to change complicated software. Despite
the simplicity of the answer, it's easier said than done!

This actually applies not only to code and architecture but also to user
interfaces, documentation, and communication. Regarding importance, I follow
the ["New Jersey
Style"](https://en.wikipedia.org/wiki/Worse_is_better#New_Jersey_style) model
of software design, at least in parts — especially "Simplicity is the most
important consideration in a [software] design." However, I believe that the
interface should be as simple as possible, as the user interface must be as
accessible as possible as the perception of the software by the target audience
can make the difference between winning against or losing to a competitor.
Therefore, it's necessary to provide an intuitive user interface so that users
don't have to think about how to accomplish what they want to do. They should
be able to just do it.

This answer brings up a follow-up question: What criteria has to be fulfilled
so that software counts as simple?

### The foundaton of simple code: Coupling and cohesion

This is where we enter subjective territory. From what I've experienced so far,
the most important concepts are coupling and cohesion. The reason why this
topic is so subjective is because although we want to avoid coupling when possible,
we also don't want every piece of the software to be an abstract cohesive unit
that can be used in any context. This would unavoidably introduce complexity
again. It's required to find a good balance between coupling and cohesion.

To achieve this, the process should start way before writing any code.
According to Rich Hickey, the inventor of the clojure language, the biggest
problems in programming are: 1. domain complexity and 2. misconception.

By defining the problem domain thoroughly, which takes time and a lot of
reflecting. Ideally everyone is included in this process to avoid any
misconception right from th start. This process should result in some domain
vocabulary, which describe different well-defined aspects that are part of the
programm. These can serve as a basis for which cohesive modules might be needed.
Or in the words of Matthieu Cneude:

> 1. Building cohesive modules is the priority. [...] Cohesion should be about
>    problem domains, not about technical concerns.
> 2. If I can’t be as cohesive as I want to, I ask myself why. If no good
>    reasons can be found, I try to aim for higher cohesion.
> 3. I look at the connections between the different modules while building
>    them if I can, or afterward. I ask myself: are there good reasons to couple
>    these modules? How can I reduce the coupling?  
>
> [...]  
>
> * Creating cohesive modules is the best way to avoid strong coupling. Said
>   differently: loosely coupled modules are often quite cohesive.
> * Imprecise, or high level cohesion should be avoided. Instead, we should aim
>   to have modules which are dedicated to solve a well-defined problem domain.
> [source](https://thevaluable.dev/cohesion-coupling-guide-examples/)

### Refactoring

This sound great, but what about when software has to be modified, like when we
add new features? This is where refactoring comes into play. Normally
refactoring is being thought of as a tool to remove cruft once it's gotten too
much. I'd argue that refactoring is a tool that should be utilized before we
add new features.



### Do not reinvent the wheel

Instead of falling into the
["NIH Syndrom"](https://en.wikipedia.org/wiki/Not_invented_here#In_computing)
trap, we should rely on FOSS solutions for problems that
have already been solved. This way we won't have the maintenance burden of
keeping the solutions alive or improving them while reaping the benefits of
improvements.

Code should only be written for domain-specific problems that can't be
addressed by using public solutions and then composed with the available tools
mentioned above. This way, the codebase stays as small as possible, and
maintenance remains at a minimum.

### Simple software

Simple software is easy to maintain because it is easy to understand how it
works and where to find the necessary code. The following text can be found on
[suckless.org/philosophy](suckless.org/philosophy) and has been slightly
adjusted by me:

> We focus on simplicity, clarity and frugality. Our philosophy is about
> keeping things simple, minimal and usable. Unfortunately, the tendency for
> complex, error-prone and slow software seems to be prevalent in the
> present-day software industry. We intend to prove the opposite with our
> software.  
> [source](https://suckless.org/philosophy/)

The user interface should be simple enough that it can be used intuitively by
inexperienced users (e.g., the older demographic), while power users can
navigate and interact efficiently and effortlessly.

Designing simple and elegant software is far more difficult than allowing
ad-hoc or over-ambitious features to obscure the code over time. However, one
has to pay this price to achieve reliability and maintainability. Furthermore,
minimalism results in reasonable and attainable goals. I strive to maintain
minimalism and clarity to drive development to completion.

### Software design

Designing the code and its architecture follows the evolutionary design
philosophy. It's impossible to know what the code will look like eventually.
Therefore, it makes sense to sit down with the team and discuss how to
implement the next feature only. This will include how the code could
potentially be refactored before any new code has been written. But that
refactoring should only be on a small scale. Bigger refactors should happen on
purpose at intervals instead of just when an obvious need becomes visible. This
allows the developers to keep the codebase as simple as possible, as the goal
of the refactor is to make the code simpler. This could be achieved by adding
or removing(!) abstractions. I find that a good approach to this kind of
refactoring is to reduce coupling and achieve a reasonable level of cohesion.
[Cohesion and Coupling in Software with
Examples](https://thevaluable.dev/cohesion-coupling-guide-examples/) is a very
good article that not only explains the types of coupling and cohesion that
exist but also how much cohesion should be strived for.

<a name="management"></a>
## Management

Managing software development is often thought of as a very straight forward
process. Executes define the strategy, managers plan, UI/UX design, developers
implement and, if exiting, QA tests.

This simplified version of what software development could look like (and often
it does look like that) neglects many aspects which ensures that realizing any
potential is very limited. On the one hand this process excludes those people
with detailed knowledge about the software from defining strategy or helping
planing: The developers, the UI/UX team and the QA team. On the other hand this
process outright ignores the human aspect of team dynamics. How do we make
decisions? How do we ensure that everyone is (or at least can) heard without
having to fear repercussions?

### Solution-oriented problem solving

Many job application have a specific requirement: "Solution-oriented approach".
The issue with this term is that it is very vague. From what I've seen so far,
most people seem to think that it means you should not think about problems too
much and rather "just" find a solution that works. In practice this often leads
to poor decisions with solve the problem only on the surface and, even worse,
introduce new problems which are often not recognized as they're quite hard to
see.

The way I see it is that focussing on solutions is often the wrong way. Of
course focusing on the problem only doesn't help either as then there won't
be any solution whatsoever. But the trick is to define the problem very
clearly, then define equally clearly how we can know whether we solved the
problem and - if possible - how well. This will serve as a basis for finding
and triaging different solutions. It is very important though to try to find
the potential downsides of every solution to be able to properly evaluate the
cost/benefit ratio as best as possible.

This kind of decision making process takes time, and in my opinion rightfully
so. Immature decision will cost the business a lot more time and money than the
extra time spent to find a proper solution.

The ["Problem-oriented
development"](https://en.wikipedia.org/wiki/Problem-oriented_development)
paradigm has some good ideas (I understand that the name is meant to represent
a countermovement to the process I describe above, but I think the name is
chosen equally poorly):

> * Investigating the structure of organisational problems as addressed by
>   Software Engineering;
> * Providing formalisms for modelling and representing problems;
> * Providing guidance and frameworks for problem analysis and decomposition;
> * Defining techniques for formally justifying solutions (e.g. by associating
>   problem components with solution components);
> * Supporting knowledge reuse during problem analysis (e.g. through problem
>   patterns).

### Decisions should be reached through inclusion,<br />The decision-making process must be explicit

When it comes to business decisions and strategy, those with the best knowledge
are those at the bottom: the developers, the designers, the researchers, the QA
team, etc. They work on the product, they work with the users and they see
flaws and misdirection directly. A top-down hierarchy (which includes "flat
hierarchies") all suffer from the same problem:

> executives don't set strategy. Not even the CEO sets strategy. Why? Because
> it's an illusion to believe you can enforce a strategy. [...]
> command-and-control is not very efficient for knowledge workers, because of
> the fundamental problem that for any given situation, the people who know the
> most about it are the people at the bottom, not the people at the top.  
> [source](https://apenwarr.ca/log/?m=201909)

If the main objective is to make profit, it is in the interest of the founders,
owners and shareholders to include everyone in the decision making process and
it's equally important to define the decision making process explicitly:

> [To] strive for a structureless group is as useful, and as
> deceptive, as to aim at an "objective" news story, "value-free" social science,
> or a "free" economy. A "laissez faire" group is about as realistic as a
> "laissez faire" society; the idea becomes a smokescreen for the strong or the
> lucky to establish unquestioned hegemony over others. […] For everyone to have
> the opportunity to be involved in a given group and to participate in its
> activities the structure must be explicit, not implicit. The rules of
> decision-making must be open and available to everyone, and this can happen
> only if they are formalized.  
> [source](https://www.jofreeman.com/joreen/tyranny.htm)


### Communication is the key

The [agile manifesto](https://agilemanifesto.org/) has four values, of which
the first one is:

> Individuals and interactions over processes and tools

This already indicates how important communication is. One of the original
authors of the manifesto even talked about it:

> When we talked about the Agile Manifesto and laid out the four value
> statements, with most of those value statements, we didn't care very much
> about what order they came in. But we did have an opinion about the first
> one: which is "Individuals and Interactions over Processes and Tools". To me
> that crystallized a very important part of what agile thinking is about.

### Meetings

Meetings are expensive and - if not done properly - just a waste of time for
most of the participants. It's tricky to do them right and ideally everyone is
educated about how meetings should be done. Keep them short. When discussions
start, stop them, arrange a follow-up meeting, if possible right after the
meeting. Takes notes and make them public. Only do meetings when necessary. The
following quote summarizes it perfectly:

> The most efficient meeting is no meeting. Let's start with what should be
> obvious by now: sometimes you don't need a meeting at all. For example, status
> updates almost always are better delivered in some written medium (like email)
> that can be retained for future reference, and skimmed (or ignored) faster than
> people can speak. Alas, skipping meetings doesn't solve every problem, or else
> remote work would be a lot easier for everyone.  
> [...]  
> Remember: every minute costs multiple person-minutes. Imagine a meeting where a
> manager is presenting to 9 people. That costs 1+9 person-minutes per minute. A
> single one-hour meeting costs you 10 hours of employee salaries! With modern
> tech employees, that adds up really, really fast. You need to spend it wisely.
> [...] As a meeting trends away from a presentation and toward group discussion,
> efficiency drops fast. Almost always, a discussion will be dominated by 2-3
> people, leaving the others to sit and get bored.  
> [source](https://apenwarr.ca/log/20201123)

### Adressing bugs before features

Getting rid of all bugs before features is a ridiculously difficult task. I'd
wager to say that it's even close to impossible for existing projects that
have accumulated hundrets or thousands of bug tickets. That's why it has to be
done properly right from the start.

A very promising approach is the
[Bug Triage with User Pain](https://lostgarden.home.blog/2008/05/20/improving-bug-triage-with-user-pain/).
This approach fits very well into the agile way of working as "*it is about
empowering people, not managing them*".

### Features and rejecting feature requests

Features should only be added when necessary. The following quote summarizes my
perspective perfectly:

> we don't want to blindly add features just because. We want to add them if we
> feel they are useful and pass the benefit versus cost calculation. A new
> feature doesn't just mean writing some code and merging it; it also means
> testing, maintaining and supporting it and considering it whenever another
> new feature comes up. Also, quite often specific usecases can be realized
> with different solutions.  
> [source](https://github.com/i3/i3/issues/2107#issuecomment-238251240)

<a name="tldr"></a>
## Tl;dr & Link-list

Here are some other articles that I really like and describe my way of
thinking/working much better than I could replicate here. All links above can
be found here, too.

* [Agile manifesto](https://agilemanifesto.org/)
* [Bug Triage with User Pain](https://lostgarden.home.blog/2008/05/20/improving-bug-triage-with-user-pain/)
* [Cohesion and Coupling in Software with Examples](https://thevaluable.dev/cohesion-coupling-guide-examples/)
* [Feature request: maximize command](https://github.com/i3/i3/issues/2107#issuecomment-238251240)
* [Goodbye, Clean Code](https://overreacted.io/goodbye-clean-code/)
* [Is Design Dead?](https://www.martinfowler.com/articles/designDead.html)
* [Is High Quality Software Worth the Cost?](https://martinfowler.com/articles/is-quality-worth-cost.html)
* [NIH Syndrom](https://en.wikipedia.org/wiki/Not_invented_here#In_computing)
* [New Jersey Style](https://en.wikipedia.org/wiki/Worse_is_better#New_Jersey_style)
* [OpportunisticRefactoring](https://martinfowler.com/bliki/OpportunisticRefactoring.html)
* [SelfTestingCode](https://martinfowler.com/bliki/SelfTestingCode.html)
* [The tyranny of structurelessness](https://www.jofreeman.com/joreen/tyranny.htm)
* [The wet codebase](https://www.deconstructconf.com/2019/dan-abramov-the-wet-codebase)
* [Thoughts you mightn't'a thunk about remote meetings](https://apenwarr.ca/log/20201123)
* [What do executives do, anyway?](https://apenwarr.ca/log/?m=201909)
* [Why Good Developers Write Bad Unit Tests](https://mtlynch.io/good-developers-bad-tests/)
